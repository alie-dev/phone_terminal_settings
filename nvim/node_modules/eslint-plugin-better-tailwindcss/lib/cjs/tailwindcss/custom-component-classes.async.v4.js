"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCustomComponentClasses = getCustomComponentClasses;
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const css_tree_1 = require("@eslint/css-tree");
const tailwind_csstree_1 = require("tailwind-csstree");
const cache_js_1 = require("../async-utils/cache.js");
const resolvers_js_1 = require("../async-utils/resolvers.js");
const { findAll, generate, parse } = (0, css_tree_1.fork)(tailwind_csstree_1.tailwind4);
async function getCustomComponentClasses(ctx) {
    const resolvedPath = (0, resolvers_js_1.resolveCss)(ctx, ctx.tailwindConfigPath);
    const files = await parseCssFilesDeep(ctx, resolvedPath);
    const utilities = Object.values(files).reduce((customComponentClasses, { ast }) => {
        customComponentClasses.push(...getCustomComponentUtilities(ast));
        return customComponentClasses;
    }, []);
    return utilities;
}
async function parseCssFilesDeep(ctx, resolvedPath) {
    const cssFiles = {};
    const cssFile = await parseCssFile(ctx, resolvedPath);
    if (!cssFile) {
        return cssFiles;
    }
    cssFiles[resolvedPath] = cssFile;
    for (const importPath of cssFile.imports) {
        const importedFiles = await parseCssFilesDeep(ctx, importPath);
        for (const importedFile in importedFiles) {
            cssFiles[importedFile] = importedFiles[importedFile];
        }
    }
    return cssFiles;
}
const parseCssFile = async (ctx, resolvedPath) => (0, cache_js_1.withCache)("css-file", resolvedPath, async () => {
    try {
        const content = await (0, promises_1.readFile)(resolvedPath, "utf-8");
        const ast = parse(content);
        const importNodes = findAll(ast, node => node.type === "Atrule" &&
            node.name === "import" &&
            node.prelude?.type === "AtrulePrelude");
        const imports = importNodes.reduce((imports, importNode) => {
            if (importNode.type !== "Atrule" || !importNode.prelude) {
                return imports;
            }
            const importStatement = generate(importNode.prelude).match(/["'](?<importPath>[^"']+)["']/);
            if (!importStatement) {
                return imports;
            }
            const { importPath } = importStatement.groups || {};
            const cwd = (0, node_path_1.dirname)(resolvedPath);
            const resolvedImportPath = (0, resolvers_js_1.resolveCss)(ctx, importPath, cwd);
            if (resolvedImportPath) {
                imports.push(resolvedImportPath);
            }
            return imports;
        }, []);
        return {
            ast,
            imports
        };
    }
    catch { }
});
function getCustomComponentUtilities(ast) {
    const customComponentUtilities = [];
    const componentLayers = findAll(ast, node => {
        return node.type === "Atrule" &&
            node.name === "layer" &&
            node.prelude?.type === "AtrulePrelude" &&
            generate(node.prelude).trim() === "components";
    });
    for (const layer of componentLayers) {
        const classSelectors = findAll(layer, node => node.type === "ClassSelector");
        for (const classNode of classSelectors) {
            if (classNode.type !== "ClassSelector") {
                continue;
            }
            if (customComponentUtilities.includes(classNode.name)) {
                continue;
            }
            customComponentUtilities.push(classNode.name);
        }
    }
    return customComponentUtilities;
}
//# sourceMappingURL=custom-component-classes.async.v4.js.map